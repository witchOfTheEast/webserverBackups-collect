#!/bin/bash

# Purpose: 
#   Collect backup files from webservers by pulling from remote servers
#   Copy and rename files locally to match the retention scheme
#   Rotate and remove files falling out of the retention period
#
# Guidelines:
#   Each backup file is to be a single archived and compressed file containing
#   all files deemed relevant by the webmaster
#
#   Files will be retrieved via scp or sftp
#   Retrieval must use a asymmetric key pair

# Each server listed here must be:
#   Added to the serverNameToIP array
#   Added to the serverNameToUsername array
#   Added to the case statement in main ()
# 
# Each site, on each <<servername>> must be:
#   Added as a variable: <<servername>>Sites to enumerate the websites to back up
#   Ex: dev01Sites = ("amm" "fft")
#   Configured in the script on the target server
#   Must create directories on backup destination

__LOGLEVEL=4

#logFilePath=/home/webadmin/scripts/webserverBackups-collect/logFile
logFilePath=/var/log/backupadmin/scriptedBackup.log
exec 1>>${logFilePath} 
exec 2>>${logFilePath} 

declare -A logNameToLevel
logNameToLevel=([crit]="1" [error]="2" [warn]="3" [info]="4" [debug]="5")

function .log () {
    local levelName=${1};
    local level=${logNameToLevel[${levelName}]};

    # this moves the parameter numbers;
    shift;
    if [[ ${__LOGLEVEL} -ge ${level} ]]; then
        echo -e "[${levelName}]" "$@";
    fi;
}


timeStamp=$(date +%Y%m%0d-%H:%M:%S)
.log debug "*****************"
.log crit "${timeStamp}"


declare srcServerNames

# Must manually add/remove servers
srcServerNames=("dev01" "doweb01" "lm" "amm-prod-web-01")
.log debug "List of servers to pull from: ${srcServerNames[@]}"

# Declaring this is important because later indexing from the array doesn't get the right value otherwise
declare -A serverNameToIP
declare -A serverNameToUsername

# Must manually add/remove servers
serverNameToIP=([dev01]="97.93.161.250" [doweb01]="138.68.22.173" [lm]="198.71.227.7" [amm-prod-web-01]="97.93.161.252");
serverNameToUsername=([dev01]="backupadmin" [doweb01]="backupadmin" [lm]="fftlifestyle" [amm-prod-web-01]="backupadmin");

# Must manually add/remove sites you wish to back up
# Any new sites need to be added to the case statement
doweb01Sites=("amm" "mam")
dev01Sites=("amm" "fft")
lmSites=("lm")
amm-prod-web-01Sites=("amm")

identityFilePath="/home/webadmin/.ssh/id_rsa"

currentDate="$(date +%Y%m%0d)"
currentYear="$(date +%Y)"
currentMonth="$(date +%m)"
#currentMonth="01"
currentDay="$(date +%0d)"
#currentDay="01"

maxYears=6

oldestYear=$(expr $currentYear - $maxYears)

maxMonths=12 # This doesn't actually do anything. The number of months to use 
             #is set in the for loop within monthly_rotation ()

destDir="/home/webadmin/backups/"
oldDir="/home/webadmin/backups/removedBackups/"
fileExtension=".tar.gz"

is_directory () {
    # Return when the argument is longer than 0 and a valid directory
    # exit if not
    # Argument: $1 -> path

    path="${1}";
    .log debug "Starting is_directory ()";
    .log debug "Testing ${path}";

    if [[ -z "${path}" ]]; then
        .log crit "is_directory () :: received argument of length 0";
        exit 1;
    elif [[ ! -d "${path}" ]]; then
        .log crit "is_directory () :: ${path} is not a valid directory";
        exit 1;
    else
        .log debug "is_directory (${path}) is true";
        .log debug "Returning from is_directory ()";
    fi;
}

list_files () {
    # Return a list of files for the specified directory
    #
    # Arguments: $1 -> a directory path
    
    .log debug "Starting list_files ()";
    is_directory $1;
    ls $1;

}

count_files () {
    # Return the number of files in a directory matching a specified backup
    # category
    #
    # Arguments: $1 -> a directory path
    #            $2 -> file backup category; one of ( daily | monthly | yearly )

    path=${1};
    keyword="${2}";

    #cannot make this log entry
    #.log debug "Starting count_files ()";

    if [[ -z "${keyword}" ]]; then
        .log error "count_files () :: Received invalid argument: $2";
        exit 1;

    else
        category=${2}
        case ${category} in 
            daily)
                value="$(ls $1 | grep -i daily | wc -l)";
                echo "${value}";
                ;;
            monthly)
                ls $1 | grep -i monthly | wc -l;
                ;;
            yearly) 
                ls $1 | grep -i yearly | wc -l;
                ;;
                
            *)
                .log error "count_files:case :: Received invalid argument: $2";
                exit 1;
                ;;
        esac;
    fi; 
}

daily_rotation () {
    # Remove files older than 7 days from a directory
    #
    # Arguments: $1 -> a directory path
    path=${1};
    .log debug "Starting daily_rotation ()";
    
    keyword="daily";

    fileCount=$(count_files ${path} ${keyword});
   
    .log debug "Initial number of ${keyword} files: ${fileCount}";
    if [[ "${fileCount}" -ge 7 ]]; then
        .log debug "Finding files older than ${currentDate} - 7 days";
        find ${path} -mtime +7 -iname "*daily*";
        
        .log info "Old $keyword files ''deleted'' to ${oldDir}";
        find ${path} -mtime +7 -iname "*daily*" -exec mv '{}' ${oldDir} \; ;
        
    fi;
     
    
    fileCount=$(count_files $path $keyword);
    .log debug "Ending number of $keyword files: $fileCount";

    .log debug "Folder contents:\n$(ls $path | grep $keyword)";

}

monthly_rotation() {
    # Remove files older than 6 months from a directory
    # For younger than 6 months, remove all but the oldest file for that month
    #
    # Arguments: $1 -> a directory path

    .log debug "Starting monthly rotation ()";

    path=${1};

    keyword=monthly

    fileCount=$(count_files $path $keyword);
    
    .log debug "Initial number of $keyword files: $fileCount";

    .log debug "$(ls ${path} | grep $keyword)";

    .log debug "Finding files older than $(expr 346 / 30 ) months";

    # Using +346 to catch files from the previous year/current month
    find ${path} -mtime +346 -iname "*monthly*" -exec rm '{}' \;

    # Important to only select files of the monthly category
    unsortedArray=($(find ${path} -iname "*monthly*" -printf "%TY,%Tm,%Td,%T@,%p\n"))
    sortedByYear=($(echo "${unsortedArray[@]}" | tr " " "\n" | sort | tr " " "\n"))

    activeYear=$currentYear
    activeMonth=$currentMonth
    
    # This range sets how many months to count back
    for i in {0..11}; do
        activeYear=$(date -d "-${i} month" +%Y);
        activeMonth=$(date -d "-${i} month" +%m);
            .log debug "Active year/month: ${activeYear}/$activeMonth";

        selectedYearMonth=($(echo "${sortedByYear[@]}" |  awk -F, -vyear="$activeYear" -vmonth="$activeMonth" 'BEGIN { RS = " " }; $1 == year && $2 == month { print $0 }'));
        numberOfElements=${#selectedYearMonth[@]};
        lastIndex=$(expr ${#selectedYearMonth[@]} - 1);
        
            .log debug "There are ${#selectedYearMonth[@]} elements";
            .log debug $(echo ${selectedYearMonth[@]} | tr " " "\n");

        if [[ ${numberOfElements} -gt 1 ]]; then
                .log debug  "Items to delete:\n";
                .log debug ${selectedYearMonth[@]:1:${lastIndex}} | tr " " "\n";
                .log debug "Deleting...";
            rm $(echo ${selectedYearMonth[@]:1:${lastIndex}} | awk -F, 'BEGIN { RS = " " }; { print $5 }');

                .log debug "The remaining files:\n";    
                .log debug $(ls ${path} | grep $keyword | grep ${activeYear} | grep ${activeMonth});

            else
                .log info "One file found per year/month, no additional files deleted";
                #echo "One file found per year/month, no additional files deleted";

        fi;

    done;
    
    .log debug "Now there should be a maximum of ${maxMonths} $keyword files\n";

    .log debug $(ls ${path} | grep $keyword);
}

yearly_rotation() {

    # Remove files older than 5 years from a directory
    # For files younger that 5 years, remove all but the oldest file in that year
    #echo "";
    .log debug "Starting yearly_rotation";

    path=$1

    keyword=yearly
   
    fileCount=$(count_files $path $keyword);
    
    .log debug "Starting number of $keyword files: $fileCount";

    .log debug "$(ls ${path} | grep yearly)";

    .log debug "Finding files older than $(expr 1825 / 365) years.";
    # 5 years equals 1825 days
    find ${path} -mtime +1825 -iname "*yearly*" -exec rm '{}' \;


    unsortedArray=($(find ${path} -iname "*yearly*" -printf "%TY,%Tm,%Td,%T@,%p\n"))
    sortedByYear=($(echo "${unsortedArray[@]}" | tr " " "\n" | sort | tr " " "\n"))

    activeYear=$currentYear

    while [[ $activeYear -gt $oldestYear ]]; do
        .log debug "The year is: $activeYear";

        selectedYear=($(echo "${sortedByYear[@]}" |  awk -F, -vyear="$activeYear" 'BEGIN { RS = " " }; $1 == year { print $0 }'));
        numberOfElements=${#selectedYear[@]};
        lastIndex=$(expr ${#selectedYear[@]} - 1);


            .log debug  "There are ${#selectedYear[@]} elements";
            .log debug $(echo ${selectedYear[@]} | tr " " "\n");

        if [[ ${numberOfElements} -gt 1 ]]; then
                .log debug "Items to delete:\n";
                .log debug $(echo ${selectedYear[@]:1:${lastIndex}} | tr " " "\n");
                .log debug "Deleting...";

            rm $(echo ${selectedYear[@]:1:${lastIndex}} | awk -F, 'BEGIN { RS = " " }; { print $5 }');

                .log debug "Confirming the remaining files:\n";    
                .log debug $(ls ${path} | grep ${activeYear});

            else
                .log debug "One file found per year. No additional files to delete.";
                #echo "One file found per year. No additional files to delete.";
        fi;
        let "activeYear -= 1";

    done;

    .log debug "Now there should be a maximum of ${maxYears} ${keyword} files\n";

    .log debug "$(ls ${path} | grep yearly)";

}

pull_files () {
    # Retrieve backup files from remote servers
    # Copy and rename files 
    # 
    # Arguments: $1 -> path
    #            $2 -> server name
    #            $3  -> site name
    
    .log debug "Starting pull_files ()";
    path="${1}"; 
    serverName=${2};
    siteName=${3};
   
    serverIP=${serverNameToIP[${serverName}]};
    serverUsername=${serverNameToUsername[$serverName]};
    .log debug "IP: ${serverIP}";

    srcFileNamePath="backups/${siteName}_backup${fileExtension}";
    .log info "Source file: ${srcFileNamePath}";

    destFilePathName="${path}${serverName}_${siteName}_${currentDate}${fileExtension}"
    .log info "Destination File: ${destFilePathName}";

    .log debug "Running: scp -i ${identityFilePath} ${serverUsername}@${serverIP}:${srcFileNamePath} ${destFilePathName}";
    scp -i ${identityFilePath} ${serverUsername}@${serverIP}:${srcFileNamePath} ${destFilePathName};

    if ! [[ -e ${destFilePathName} ]]; then
        .log  error "scp failed. NOT FOUND - ${destFilePathName}";
        #echo "scp failed. NOT FOUND - ${destFilePathName}";
    else
        keywordArray=(daily);
        
        if [[ "${currentMonth}${currentDay}" == 0101 ]]; then
            keywordArray+=("yearly");
        fi;
        
        if [[ "${currentDay}" == 01 ]]; then
            keywordArray+=("monthly");
        fi;

        
        .log debug "The backup type array:\n${keywordArray[@]}\n";
        echo ${keywordArray[1]};
        for keyword in ${keywordArray[@]}; do
            
            newFilePathName="${path}${serverName}_${siteName}_${keyword}_${currentDate}${fileExtension}"
            .log debug "Copying to: ${newFilePathName}";
            cp ${destFilePathName} ${newFilePathName} 
        done;

        fileCount=$(ls ${path} | wc -l);
        
        if [[ ${fileCount} -ge 2 ]]; then
            .log info "Removing ${destFilePathName}";
            rm ${destFilePathName};

            .log debug "Attempting to rename the source file on the server to _old";
            ssh -i ${identityFilePath} ${serverUsername}@${serverIP} "cp ${srcFileNamePath} ${srcFileNamePath}_old && rm ${srcFileNamePath}";
        echo "FAKE SSH RENAME NOW"
        fi
    fi

}

execute_things () {
        serverName="${1}";
        siteName="${2}";
        path="${destDir}${serverName}/${siteName}/";
        
        .log debug "Starting execute_things ()";
        .log info "Source: ${serverName} - ${siteName}";
        .log debug "Calling is_directory () from execute_things ()";
        is_directory ${path};

        .log debug "Destination path: ${path}";

        if [[ ! -d ${path} ]]; then
            .log warn "Destination path: NOT FOUND.\nAttempting to create ${path}";
            mkdir -p ${path};
        fi;


        pull_files $path $serverName $siteName;

        .log debug "Calling daily_rotation ()";
        daily_rotation $path;
        
        if [[ ${currentDay} == 01 ]]; then 

            .log debug "Calling monthly_rotation ()";
             monthly_rotation $path;

            if [[ ${currentMonth} == 01 ]];  then

                .log debug "Calling yearly_rotation ()";
                yearly_rotation $path;
            
            fi;
        fi;

}

main () {
    # For server name, find the sites then execute the pull and rotation on each site
    .log debug "Starting main loop";

    for i in ${srcServerNames[@]}; do
        serverName="${i}";
        .log debug "Starting on server: ${serverName}";

        case ${serverName} in
            doweb01)
                for siteName in ${doweb01Sites[@]}; do
                    execute_things $serverName $siteName;
                done;
                ;;

            dev01)
                for siteName in ${dev01Sites[@]}; do
                    execute_things $serverName $siteName;
                done;
                ;;

            lm) 
                for siteName in ${lmSites[@]}; do
                    execute_things $serverName $siteName;
                done;
                ;;

            amm-prod-web-01) 
                for siteName in ${amm-prod-web-01[@]}; do
                    execute_things $serverName $siteName;
                done;
                ;;
            *)
                .log crit "main () :: received an invalid argument ${i}";
                exit 1;
                ;;

        esac
    done
    .log info "End of main ()";
}

main;

.log crit "End of script";
